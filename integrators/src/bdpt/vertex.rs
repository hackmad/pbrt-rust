//! Path vertex

#![allow(dead_code)]
use super::common::*;
use core::camera::*;
use core::geometry::*;
use core::interaction::*;
use core::light::*;
use core::material::TransportMode;
use core::pbrt::*;
use core::reflection::*;
use core::sampling::Distribution1D;
use core::scene::*;
use core::spectrum::*;
use std::collections::HashMap;
use std::fmt;
use std::sync::Arc;

/// Types of path vertices.
#[derive(Clone)]
pub(crate) enum VertexType {
    Camera,
    Light,
    Surface,
    Medium,
}

impl fmt::Display for VertexType {
    /// Formats the value using the given formatter.
    ///
    /// * `f` - Formatter.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Camera => write!(f, "camera"),
            Self::Light => write!(f, "light"),
            Self::Surface => write!(f, "surface"),
            Self::Medium => write!(f, "medium"),
        }
    }
}

/// Vertex represents any kind of path vertex and encapsulates conditional logic to handle different
/// cases between pairs of vertices.
#[derive(Clone)]
pub(crate) struct Vertex<'scene> {
    /// The path vertex type.
    pub(crate) vertex_type: VertexType,

    /// Tracks β which is the product of the BSDF or phase function values, transmittances, and cosine
    /// terms for the vertices in the path generated, divided by their respective sampling PDFs.
    pub(crate) beta: Spectrum,

    /// The interaction information for the vertex.
    pub(crate) it: Interaction<'scene>,

    /// The BSDF for surface interactions.
    pub(crate) bsdf: Option<BSDF>,

    /// Used by surface interactions and records whether a Dirac delta function was sampled (e.g.,
    /// when light is scattered by a perfectly specular material).
    pub(crate) delta: bool,

    /// Forward density of the current vertex, which is the probability per unit area of the current
    /// vertex as generated by the path sampling algorithm.
    pub(crate) pdf_fwd: Float,

    /// The hypothetical probability density of the vertex if the direction of light transport was
    /// reversed—that is, if radiance transport was used in place of importance transport for the
    /// camera path and vice versa for the light path. Used for computing MIS weights.
    pub(crate) pdf_rev: Float,
}

impl<'scene> Vertex<'scene> {
    /// Create a new `Vertex<'scene>` from an endpoint interaction.
    ///
    /// * `vertex_type` - The vertex type.
    /// * `ei`          - The endpoint interaction.
    /// * `beta`        - Tracks β which is the product of the BSDF or phase function values,
    ///                   transmittances, and cosine terms for the vertices in the path generated,
    ///                   divided by their respective sampling PDFs.
    pub(crate) fn new(vertex_type: VertexType, ei: EndpointInteraction, beta: Spectrum) -> Self {
        Self {
            vertex_type,
            beta,
            it: Interaction::Endpoint { ei },
            bsdf: None,
            delta: false,
            pdf_fwd: 0.0,
            pdf_rev: 0.0,
        }
    }

    /// Create a new `Vertex<'scene>` from an medium interaction.
    ///
    /// * `mi`   - The medium interaction.
    /// * `beta` - Tracks β which is the product of the BSDF or phase function values,
    ///            transmittances, and cosine terms for the vertices in the path generated,
    ///            divided by their respective sampling PDFs.
    pub(crate) fn new_medium_interaction(mi: MediumInteraction, beta: Spectrum) -> Self {
        Self {
            vertex_type: VertexType::Medium,
            beta,
            it: Interaction::Medium { mi },
            bsdf: None,
            delta: false,
            pdf_fwd: 0.0,
            pdf_rev: 0.0,
        }
    }

    /// Create a new `Vertex<'scene>` from a surface interaction.
    ///
    /// * `si`   - The surface interaction.
    /// * `bsdf` - The BSDF at the interaction.
    /// * `beta` - Tracks β which is the product of the BSDF or phase function values,
    ///            transmittances, and cosine terms for the vertices in the path generated,
    ///            divided by their respective sampling PDFs.
    pub(crate) fn new_surface_interaction(si: SurfaceInteraction<'scene>, bsdf: BSDF, beta: Spectrum) -> Self {
        Self {
            vertex_type: VertexType::Surface,
            beta,
            it: Interaction::Surface { si },
            bsdf: Some(bsdf),
            delta: false,
            pdf_fwd: 0.0,
            pdf_rev: 0.0,
        }
    }

    /// Create a new `Vertex<'scene>` from a ray starting at a point on a camera lens.
    ///
    /// * `camera` - The camera.
    /// * `ray`    - The ray starting on the camera lens.
    /// * `beta`   - Tracks β which is the product of the BSDF or phase function values,
    ///              transmittances, and cosine terms for the vertices in the path generated,
    ///              divided by their respective sampling PDFs.
    pub(crate) fn create_camera_from_ray(camera: ArcCamera, ray: &Ray, beta: Spectrum) -> Self {
        Self::new(
            VertexType::Camera,
            EndpointInteraction::camera_from_ray(ray, camera),
            beta,
        )
    }

    /// Create a new `Vertex<'scene>` from an interaction point on a camera lens.
    ///
    /// * `camera` - The camera.
    /// * `it`     - The interaction on the camera lens.
    /// * `beta`   - Tracks β which is the product of the BSDF or phase function values,
    ///              transmittances, and cosine terms for the vertices in the path generated,
    ///              divided by their respective sampling PDFs.
    pub(crate) fn create_camera_from_interaction(camera: ArcCamera, it: &Interaction, beta: Spectrum) -> Self {
        Self::new(
            VertexType::Camera,
            EndpointInteraction::camera_from_hit(it.get_hit(), camera),
            beta,
        )
    }

    /// Create a new `Vertex<'scene>` from a hit point on a camera lens.
    ///
    /// * `camera` - The camera.
    /// * `it`     - The hit point on the camera lens.
    /// * `beta`   - Tracks β which is the product of the BSDF or phase function values,
    ///              transmittances, and cosine terms for the vertices in the path generated,
    ///              divided by their respective sampling PDFs.
    pub(crate) fn create_camera_from_hit(camera: ArcCamera, hit: &Hit, beta: Spectrum) -> Self {
        Self::new(
            VertexType::Camera,
            EndpointInteraction::camera_from_hit(hit, camera),
            beta,
        )
    }

    /// Create a new `Vertex<'scene>` from a ray starting at a point on a light source.
    ///
    /// * `light`   - The light source.
    /// * `ray`     - The ray starting on the light source.
    /// * `n_light` - The ray starting on the light source.
    /// * `le`      - Used for β which is the product of the BSDF or phase function values,
    ///               transmittances, and cosine terms for the vertices in the path generated,
    ///               divided by their respective sampling PDFs.
    /// * `pdf`     - The light PDF.
    pub(crate) fn create_light_from_ray_normal(
        light: ArcLight,
        ray: &Ray,
        n_light: &Normal3f,
        le: Spectrum,
        pdf: Float,
    ) -> Self {
        let mut v = Self::new(
            VertexType::Light,
            EndpointInteraction::light_from_ray_and_normal(ray, *n_light, Some(light)),
            le,
        );
        v.pdf_fwd = pdf;
        v
    }

    /// Create a new `Vertex<'scene>` from a surface interaction.
    ///
    /// * `si`    - The surface interaction.
    /// * `bsdf`  - The BSDF at the interaction point.
    /// * `beta`  - Tracks β which is the product of the BSDF or phase function values,
    ///             transmittances, and cosine terms for the vertices in the path generated,
    ///             divided by their respective sampling PDFs.
    /// * `pdf`   - The PDF at the interaction point.
    /// * `prev`  - The previous vertex in the path.
    pub(crate) fn create_surface(
        si: SurfaceInteraction<'scene>,
        bsdf: BSDF,
        beta: Spectrum,
        pdf: Float,
        prev: &Vertex,
    ) -> Self {
        let mut v = Self::new_surface_interaction(si, bsdf, beta);
        v.pdf_fwd = prev.convert_density(pdf, &v);
        v
    }

    /// Create a new `Vertex<'scene>` from a medium interaction.
    ///
    /// * `mi`    - The medium interaction.
    /// * `beta`  - Tracks β which is the product of the BSDF or phase function values,
    ///             transmittances, and cosine terms for the vertices in the path generated,
    ///             divided by their respective sampling PDFs.
    /// * `pdf`   - The PDF at the interaction point.
    /// * `prev`  - The previous vertex in the path.
    pub(crate) fn create_medium(mi: MediumInteraction, beta: Spectrum, pdf: Float, prev: &Vertex) -> Self {
        let mut v = Self::new_medium_interaction(mi, beta);
        v.pdf_fwd = prev.convert_density(pdf, &v);
        v
    }

    /// Create a new `Vertex<'scene>` from an endpoint interaction.
    ///
    /// * `ei`    - The endpoint interaction.
    /// * `beta`  - Tracks β which is the product of the BSDF or phase function values,
    ///             transmittances, and cosine terms for the vertices in the path generated,
    ///             divided by their respective sampling PDFs.
    /// * `pdf`   - The PDF at the interaction point.
    pub(crate) fn create_light_from_endpoint_interaction(ei: EndpointInteraction, beta: Spectrum, pdf: Float) -> Self {
        let mut ret = Self::new(VertexType::Light, ei, beta);
        ret.pdf_fwd = pdf;
        ret
    }

    /// Returns true if the vertex (including endpoints) is located on a surface.
    pub(crate) fn is_on_surface(&self) -> bool {
        self.it.ng() != Normal3f::ZERO
    }

    /// Evaluates the portion of the path-space measurement equation associated with a vertex.
    /// NOTE: This is only handled surface and medium interactions.
    ///
    /// * `next` - The next vertex in the path.
    /// * `mode` - The light transport mode.
    pub(crate) fn f(&self, next: &Vertex, mode: TransportMode) -> Spectrum {
        let mut wi = next.it.p() - self.it.p();
        if wi.length_squared() == 0.0 {
            return Spectrum::ZERO;
        }

        wi = wi.normalize();
        match &self.it {
            Interaction::Surface { si } => {
                self.bsdf.as_ref().unwrap().f(&si.hit.wo, &wi, BxDFType::all())
                    * correct_shading_normal(&si, &si.hit.wo, &wi, mode)
            }
            Interaction::Medium { mi } => Spectrum::new(mi.phase.p(&mi.hit.wo, &wi)),
            _ => unreachable!(),
        }
    }

    /// Returns true if a connection strategy involving the current vertex can succeed.
    pub(crate) fn is_connectible(&self) -> bool {
        match &self.it {
            Interaction::Medium { mi: _ } => true,
            Interaction::Endpoint {
                ei: EndpointInteraction::Camera { hit: _, camera: _ },
            } => true,
            Interaction::Endpoint {
                ei: EndpointInteraction::Light { hit: _, light },
            } => match light {
                Some(l) => l.get_type().matches(LightType::DELTA_DIRECTION_LIGHT),
                None => false,
            },
            Interaction::Surface { si: _ } => self.bsdf.as_ref().map_or(false, |bsdf| {
                bsdf.num_components(
                    BxDFType::BSDF_DIFFUSE
                        | BxDFType::BSDF_GLOSSY
                        | BxDFType::BSDF_REFLECTION
                        | BxDFType::BSDF_TRANSMISSION,
                ) > 0
            }),
        }
    }

    /// Returns true if the vertex is a light endpoint interaction or an area light source.
    pub(crate) fn is_light(&self) -> bool {
        match &self.it {
            Interaction::Endpoint {
                ei: EndpointInteraction::Light { hit: _, light: _ },
            } => true,
            Interaction::Surface { si } => si.primitive.map_or(false, |p| p.get_area_light().is_some()),
            _ => false,
        }
    }

    /// Returns true if the vertex is a light endpoint interaction or a delta light (has a Dirac
    /// delta distribution).
    pub(crate) fn is_delta_light(&self) -> bool {
        match &self.it {
            Interaction::Endpoint {
                ei: EndpointInteraction::Light { hit: _, light },
            } => match light {
                Some(l) => l.is_delta_light(),
                None => false,
            },
            _ => false,
        }
    }

    /// Returns true if the vertex is a light endpoint interaction, an infinite light source or a
    /// delta direction light source.
    pub(crate) fn is_infinite_light(&self) -> bool {
        match &self.it {
            Interaction::Endpoint {
                ei: EndpointInteraction::Light { hit: _, light },
            } => match light {
                Some(l) => {
                    l.get_type().matches(LightType::DELTA_DIRECTION_LIGHT)
                        || l.get_type().matches(LightType::INFINITE_LIGHT)
                }
                None => false,
            },
            _ => false,
        }
    }

    /// Calculate the emitted radiance from an intersected light source toward another vertex.
    ///
    /// * `scene` - The scene.
    /// * `v`     - The other vertex.
    pub(crate) fn le(&self, scene: &Scene, v: &Self) -> Spectrum {
        if !self.is_light() {
            return Spectrum::ZERO;
        }

        let mut w = v.it.p() - self.it.p();
        if w.length_squared() == 0.0 {
            return Spectrum::ZERO;
        };

        w = w.normalize();
        if self.is_infinite_light() {
            // Return emitted radiance for infinite light sources.
            let mut le = Spectrum::ZERO;
            for light in scene.infinite_lights.iter() {
                le += light.le(&Ray::new(self.it.p(), -w, Float::MAX, 0.0, None));
            }
            le
        } else {
            // Must be an area light.
            match &self.it {
                Interaction::Surface { si } => match si.primitive {
                    Some(p) => {
                        let light = p.get_area_light();
                        assert!(light.is_some());
                        light.unwrap().l(&si.hit, &w)
                    }
                    None => unreachable!(),
                },
                _ => Spectrum::ZERO, //unreachable!(),
            }
        }
    }

    /// Returns the product of this Jacobian (computed from the vertex attributes) and the pdf parameter,
    /// which should express a solid angle density at the vertex.
    ///
    /// * `pdf`  - The PDF.
    /// * `next` - The next vertex in the path.
    pub(crate) fn convert_density(&self, pdf: Float, next: &Self) -> Float {
        // Return solid angle density if `next` is an infinite area light.
        if next.is_infinite_light() {
            return pdf;
        }

        let w = next.it.p() - self.it.p();
        let w_len_sq = w.length_squared();
        if w_len_sq == 0.0 {
            return 0.0;
        }

        let inv_dist_2 = 1.0 / w_len_sq;
        if next.is_on_surface() {
            pdf * next.it.ng().abs_dot(&(w * inv_dist_2.sqrt())) * inv_dist_2
        } else {
            pdf * inv_dist_2
        }
    }

    /// Returns the probability per unit area of the sampling technique associated with a given vertex.
    ///
    /// * `scene` - The scene.
    /// * `prev`  - The previous vertex in the path.
    /// * `next`  - The next vertex in the path.
    pub(crate) fn pdf(&self, scene: &Scene, prev: Option<&Vertex>, next: &Vertex) -> Float {
        if matches!(self.vertex_type, VertexType::Light) {
            return self.pdf_light(scene, next);
        }

        // Compute directions to preceding and next vertex.
        let mut wn = next.it.p() - self.it.p();
        if wn.length_squared() == 0.0 {
            return 0.0;
        }

        wn = wn.normalize();

        let mut wp = Vector3f::default();
        if let Some(prv) = prev {
            wp = prv.it.p() - self.it.p();
            if wp.length_squared() == 0.0 {
                return 0.0;
            };
            wp = wp.normalize();
        } else {
            assert!(matches!(self.vertex_type, VertexType::Camera));
        }

        // Compute directional density depending on the vertex types.
        let pdf = match &self.it {
            Interaction::Endpoint {
                ei: EndpointInteraction::Camera { hit, camera },
            } => {
                let ray = hit.spawn_ray(&wn);
                let PDFResult { pos: _, dir: pdf } = camera.pdf_we(&ray);
                pdf
            }
            Interaction::Surface { si: _ } => self
                .bsdf
                .as_ref()
                .map_or(0.0, |bsdf| bsdf.pdf(&wp, &wn, BxDFType::all())),
            Interaction::Medium { mi } => mi.phase.p(&wp, &wn),
            _ => panic!("Vertex::pdf(): Unimplemented"),
        };

        // Return probability per unit area at vertex `next`.
        self.convert_density(pdf, next)
    }

    /// Returns the probability per unit area for a light vertex.
    ///
    /// * `scene` - The scene.
    /// * `v`     - The vertex.
    pub(crate) fn pdf_light(&self, scene: &Scene, v: &Vertex) -> Float {
        let mut w = v.it.p() - self.it.p();
        let inv_dist_2 = 1.0 / w.length_squared();
        w *= inv_dist_2.sqrt();

        let pdf = if self.is_infinite_light() {
            // Compute planar sampling density for infinite light sources.
            let (_world_center, world_radius) = scene.world_bound.bounding_sphere();
            1.0 / (PI * world_radius * world_radius)
        } else {
            // Get pointer `light` to the light source at the vertex.
            let light = match &self.it {
                Interaction::Endpoint {
                    ei: EndpointInteraction::Light { hit: _, light },
                } => match light {
                    Some(l) => Some(Arc::clone(l)),
                    None => None,
                },
                Interaction::Surface { si } => match si.primitive {
                    Some(p) => p.get_area_light(),
                    None => None,
                },
                _ => None,
            }
            .expect("Cannot call Vertex::pdf_light() on path vertex that is not a light source");

            // Compute sampling density for non-infinite light sources
            let Pdf { pdf_pos: _, pdf_dir } =
                light.pdf_le(&Ray::new(self.it.p(), w, INFINITY, self.it.time(), None), &self.it.ng());
            pdf_dir * inv_dist_2
        };

        if v.is_on_surface() {
            pdf * v.it.ng().abs_dot(&w)
        } else {
            pdf
        }
    }

    /// Returns the probability per unit area for path endpoints whose sampling routines generate rays
    /// from a 4D distribution.
    ///
    /// * `scene`                - The scene.
    /// * `v`                    - The vertex.
    /// * `light_distr`          - Light probabilities.
    /// * `light_to_distr_index` - Map of light distribution indices.
    pub(crate) fn pdf_light_origin(
        &self,
        scene: &Scene,
        v: &Vertex,
        light_distr: Arc<Distribution1D>,
        light_to_distr_index: Arc<HashMap<usize, usize>>,
    ) -> Float {
        let mut w = v.it.p() - self.it.p();
        if w.length_squared() == 0.0 {
            return 0.0;
        }

        w = w.normalize();
        if self.is_infinite_light() {
            // Return solid angle density for infinite light sources.
            infinite_light_density(scene, light_distr, light_to_distr_index, &w)
        } else {
            // Return solid angle density for non-infinite light sources.

            // Get pointer `light` to the light source at the vertex.
            let light = match &self.it {
                Interaction::Endpoint {
                    ei: EndpointInteraction::Light { hit: _, light },
                } => match light {
                    Some(l) => Some(Arc::clone(l)),
                    None => None,
                },
                Interaction::Surface { si } => match si.primitive {
                    Some(p) => p.get_area_light(),
                    None => None,
                },
                _ => None,
            }
            .expect("Cannot call Vertex::pdf_light() on path vertex that is not a light source");

            // Compute the discrete probability of sampling `light`, `pdf_choice`.
            let index = light_to_distr_index
                .get(&light.get_id())
                .expect("Light ID not found in light_to_distr_index map");
            let pdf_choice = light_distr.discrete_pdf(*index);

            let Pdf { pdf_pos, pdf_dir: _ } =
                light.pdf_le(&Ray::new(self.it.p(), w, INFINITY, self.it.time(), None), &self.it.ng());
            pdf_pos * pdf_choice
        }
    }
}

impl<'scene> Default for Vertex<'scene> {
    /// Returns the "default value" for `Vertex<'scene>`.
    fn default() -> Self {
        Self::new(
            VertexType::Light,
            EndpointInteraction::Light {
                hit: Hit::default(),
                light: None,
            },
            Spectrum::ZERO,
        )
    }
}

impl<'scene> fmt::Display for Vertex<'scene> {
    /// Formats the value using the given formatter.
    ///
    /// * `f` - Formatter.
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "[Vertex type: {}", self.vertex_type)?;
        write!(f, " connectible: {}", self.is_connectible())?;
        write!(f, " p: {} ng: {}", self.it.p(), self.it.ng())?;
        write!(
            f,
            " pdfFwd: {} pdfRev: {} beta: {}",
            self.pdf_fwd, self.pdf_rev, self.beta
        )?;
        match &self.it {
            Interaction::Surface { si: _ } => write!(f, "\n  bsdf: {}", self.bsdf.as_ref().unwrap())?,
            Interaction::Medium { mi } => write!(f, "\n  phase: {}", mi.phase)?,
            _ => (),
        }
        write!(f, "]")
    }
}
